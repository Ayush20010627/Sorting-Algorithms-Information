<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sorting Algorithms Information</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <style>
    body {
      background-color: black;
      color: white;
      font-family: Arial, sans-serif;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
    }

    h2 {
      margin-top: 40px;
    }

    p {
      margin-bottom: 20px;
    }

    span {
      font-size: 18px;
      font-weight: bold;
    }

    a {
      color: #007bff;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    pre {
      background-color: #1e1e1e;
      padding: 20px;
      border-radius: 5px;
      overflow-x: auto;
    }

    code {
      color: white;
    }

    .btn {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #007bff;
      color: white;
      border: none;
      cursor: pointer;
      outline: none;
      margin-bottom: 20px;
    }

    .btn:hover {
      background-color: #0056b3;
    }

    .demo-code {
      background-color: #282c34;
      color: #abb2bf;
      padding: 20px;
      border-radius: 5px;
      margin-top: 20px;
    }

    .demo-code pre {
      background-color: transparent;
      padding: 0;
    }

    .demo-code code {
      color: #abb2bf;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Sorting Algorithms Information</h1>

    <!-- Buttons -->
    <div>
      <button class="btn" onclick="showAlgorithm('bubble')">Bubble Sort</button>
      <button class="btn" onclick="showAlgorithm('selection')">Selection Sort</button>
      <button class="btn" onclick="showAlgorithm('insertion')">Insertion Sort</button>
      <button class="btn" onclick="showAlgorithm('heap')">Heap Sort</button>
      <button class="btn" onclick="showAlgorithm('merge')">Merge Sort</button>
      <button class="btn" onclick="showAlgorithm('quick')">Quick Sort</button>
      <button class="btn" onclick="showAlgorithm('shell')">Shell Sort</button>
      <button class="btn" onclick="showAlgorithm('cocktail')">Cocktail Sort</button>
    </div>

    <!-- Algorithm Info -->
    <div id="algorithm-info"></div>

    <!-- Algorithm Demo -->
    <div id="algorithm-demo" class="demo-code"></div>
  </div>

  <script>
    function showAlgorithm(algorithm) {
      const algorithmInfo = document.getElementById('algorithm-info');
      const algorithmDemo = document.getElementById('algorithm-demo');

      switch (algorithm) {
        case 'bubble':
          algorithmInfo.innerHTML = `
            <h2>Bubble Sort</h2>
            <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller or larger elements "bubble" to the top of the list. Although the algorithm is simple, it is too slow and impractical for most problems.</p>
            <p><strong>Worst Case:</strong> O(n^2)</p>
            <p><strong>Average Case:</strong> O(n^2)</p>
            <p><strong>Best Case:</strong> O(n)</p>
            <p><strong>Space Complexity:</strong> O(1)</p>
          `;
          algorithmDemo.innerHTML = `
            <pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

void bubbleSort(std::vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    for (int i = 0; i &lt; n - 1; ++i) {
        for (int j = 0; j &lt; n - i - 1; ++j) {
            if (arr[j] &gt; arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
            }
        }
    }
}

int main() {
    std::vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};
    bubbleSort(arr);
    std::cout &lt;&lt; "Sorted array: ";
    for (int num : arr) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}</code></pre>
          `;
          break;

        case 'selection':
          algorithmInfo.innerHTML = `
            <h2>Selection Sort</h2>
            <p>Selection Sort is a simple sorting algorithm that selects the smallest (or largest) element from an unsorted list in each iteration and places it in its final sorted position.</p>
            <p><strong>Worst Case:</strong> O(n^2)</p>
            <p><strong>Average Case:</strong> O(n^2)</p>
            <p><strong>Best Case:</strong> O(n^2)</p>
            <p><strong>Space Complexity:</strong> O(1)</p>
          `;
          algorithmDemo.innerHTML = `
            <pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

void selectionSort(std::vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    for (int i = 0; i &lt; n - 1; i++) {
        int min_idx = i;
        for (int j = i + 1; j &lt; n; j++)
            if (arr[j] &lt; arr[min_idx])
                min_idx = j;
        std::swap(arr[min_idx], arr[i]);
    }
}

int main() {
    std::vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};
    selectionSort(arr);
    std::cout &lt;&lt; "Sorted array: ";
    for (int num : arr) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}</code></pre>
          `;
          break;

        case 'insertion':
          algorithmInfo.innerHTML = `
            <h2>Insertion Sort</h2>
            <p>Insertion Sort is a simple sorting algorithm that builds the final sorted array (or list) one element at a time by repeatedly moving the larger elements to the right and then inserting the current element into its correct position.</p>
            <p><strong>Worst Case:</strong> O(n^2)</p>
            <p><strong>Average Case:</strong> O(n^2)</p>
            <p><strong>Best Case:</strong> O(n)</p>
            <p><strong>Space Complexity:</strong> O(1)</p>
          `;
          algorithmDemo.innerHTML = `
            <pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

void insertionSort(std::vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    for (int i = 1; i &lt; n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j &gt;= 0 && arr[j] &gt; key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

int main() {
    std::vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};
    insertionSort(arr);
    std::cout &lt;&lt; "Sorted array: ";
    for (int num : arr) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}</code></pre>
          `;
          break;

        case 'heap':
          algorithmInfo.innerHTML = `
            <h2>Heap Sort</h2>
            <p>Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure to build a max-heap and repeatedly extracts the maximum element from it and rebuilds the heap.</p>
            <p><strong>Worst Case:</strong> O(n log n)</p>
            <p><strong>Average Case:</strong> O(n log n)</p>
            <p><strong>Best Case:</strong> O(n log n)</p>
            <p><strong>Space Complexity:</strong> O(1)</p>
          `;
          algorithmDemo.innerHTML = `
            <pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

void heapify(std::vector&lt;int&gt;&amp; arr, int n, int i) {
    int largest = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;
    if (l &lt; n &amp;&amp; arr[l] &gt; arr[largest])
        largest = l;
    if (r &lt; n &amp;&amp; arr[r] &gt; arr[largest])
        largest = r;
    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(std::vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    for (int i = n / 2 - 1; i &gt;= 0; i--)
        heapify(arr, n, i);
    for (int i = n - 1; i &gt; 0; i--) {
        std::swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}

int main() {
    std::vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};
    heapSort(arr);
    std::cout &lt;&lt; "Sorted array: ";
    for (int num : arr) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}</code></pre>
          `;
          break;

        case 'merge':
          algorithmInfo.innerHTML = `
            <h2>Merge Sort</h2>
            <p>Merge Sort is a divide and conquer algorithm that divides the input array into two halves, recursively sorts each half, and then merges the sorted halves.</p>
            <p><strong>Worst Case:</strong> O(n log n)</p>
            <p><strong>Average Case:</strong> O(n log n)</p>
            <p><strong>Best Case:</strong> O(n log n)</p>
            <p><strong>Space Complexity:</strong> O(n)</p>
          `;
          algorithmDemo.innerHTML = `
            <pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

void merge(std::vector&lt;int&gt;&amp; arr, int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;
    std::vector&lt;int&gt; L(n1), R(n2);
    for (int i = 0; i &lt; n1; i++)
        L[i] = arr[l + i];
    for (int j = 0; j &lt; n2; j++)
        R[j] = arr[m + 1 + j];
    int i = 0, j = 0, k = l;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    while (i &lt; n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j &lt; n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(std::vector&lt;int&gt;&amp; arr, int l, int r) {
    if (l &lt; r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

int main() {
    std::vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};
    mergeSort(arr, 0, arr.size() - 1);
    std::cout &lt;&lt; "Sorted array: ";
    for (int num : arr) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}</code></pre>
          `;
          break;

        case 'quick':
          algorithmInfo.innerHTML = `
            <h2>Quick Sort</h2>
            <p>Quick Sort is a comparison-based sorting algorithm that partitions the array into two parts, then recursively sorts each part.</p>
            <p><strong>Worst Case:</strong> O(n^2)</p>
            <p><strong>Average Case:</strong> O(n log n)</p>
            <p><strong>Best Case:</strong> O(n log n)</p>
            <p><strong>Space Complexity:</strong> O(log n)</p>
          `;
          algorithmDemo.innerHTML = `
            <pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int partition(std::vector&lt;int&gt;&amp; arr, int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    for (int j = low; j &lt;= high - 1; j++) {
        if (arr[j] &lt; pivot) {
            i++;
            std::swap(arr[i], arr[j]);
        }
    }
    std::swap(arr[i + 1], arr[high]);
    return (i + 1);
}

void quickSort(std::vector&lt;int&gt;&amp; arr, int low, int high) {
    if (low &lt; high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    std::vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};
    quickSort(arr, 0, arr.size() - 1);
    std::cout &lt;&lt; "Sorted array: ";
    for (int num : arr) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}</code></pre>
          `;
          break;

        case 'shell':
          algorithmInfo.innerHTML = `
            <h2>Shell Sort</h2>
            <p>Shell Sort is a highly efficient sorting algorithm and is an extension of insertion sort. It divides the input array into smaller subarrays and then applies insertion sort to each subarray.</p>
            <p><strong>Worst Case:</strong> O(n^2)</p>
            <p><strong>Average Case:</strong> Depends on gap sequence</p>
            <p><strong>Best Case:</strong> O(n log n)</p>
            <p><strong>Space Complexity:</strong> O(1)</p>
          `;
          algorithmDemo.innerHTML = `
            <pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

void shellSort(std::vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    for (int gap = n / 2; gap &gt; 0; gap /= 2) {
        for (int i = gap; i &lt; n; i++) {
            int temp = arr[i];
            int j;
            for (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            arr[j] = temp;
        }
    }
}

int main() {
    std::vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};
    shellSort(arr);
    std::cout &lt;&lt; "Sorted array: ";
    for (int num : arr) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}</code></pre>
          `;
          break;

        case 'cocktail':
          algorithmInfo.innerHTML = `
            <h2>Cocktail Sort</h2>
            <p>Cocktail Sort is a variation of Bubble Sort. It traverses through the array in both directions alternatively. It sorts the array in both directions in each traversal.</p>
            <p><strong>Worst Case:</strong> O(n^2)</p>
            <p><strong>Average Case:</strong> O(n^2)</p>
            <p><strong>Best Case:</strong> O(n)</p>
            <p><strong>Space Complexity:</strong> O(1)</p>
          `;
          algorithmDemo.innerHTML = `
            <pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

void cocktailSort(std::vector&lt;int&gt;&amp; arr) {
    bool swapped = true;
    int start = 0;
    int end = arr.size() - 1;
    while (swapped) {
        swapped = false;
        for (int i = start; i &lt; end; ++i) {
            if (arr[i] &gt; arr[i + 1]) {
                std::swap(arr[i], arr[i + 1]);
                swapped = true;
            }
        }
        if (!swapped) break;
        swapped = false;
        --end;
        for (int i = end - 1; i &gt;= start; --i) {
            if (arr[i] &gt; arr[i + 1]) {
                std::swap(arr[i], arr[i + 1]);
                swapped = true;
            }
        }
        ++start;
    }
}

int main() {
    std::vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};
    cocktailSort(arr);
    std::cout &lt;&lt; "Sorted array: ";
    for (int num : arr) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}</code></pre>
          `;
          break;

        default:
          break;
      }

      // Highlight code blocks
      hljs.highlightAll();
    }
  </script>
</body>
</html>
